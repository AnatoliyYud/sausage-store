Соответсвие нашего приложения sausage-store 12 факторам написания приложений для работы в облаке.

1) Кодовая база (Codebase)
Исходники приложения должны лежать в репозитории в системе контроля версий. Одно приложение — один репозиторий. Разработчики не могут заводить свои собственные репозитории «для удобства», но могут иметь ветки с собственными версиями кодовой базы и деплоить их на тестовые стенды. Приложение не может собираться из нескольких репозиториев сразу, но может зависеть от других приложений. В этом случае они должны быть прописаны как зависимости.

Ответ: Считаю, что данный пункт подходит. Так как приложение лежит в одном репозитории gitlab. Дополнительных репозиториев создано не было, для тестов используются тестовые ветки.

2) Зависимости (Dependencies)
Не полагайтесь на наличие системных пакетов на окружении. Все пакеты, от которых зависит приложение, должны быть объявлены. Кроме того, мы должны быть уверены, что приложение будет запущено с необходимыми версиями зависимостей. Для этого существуют инструменты изоляции зависимостей.
Хорошим примером является virtualenv в python: на хосте создаётся изолированное python-окружение с необходимой версией python, далее менеджер пакетов pip устанавливает объявленные версии, не затрагивая версии системных пакетов и других venv'ов.

Ответ: Считаю, что данный пункт подходит. Для зависимостей бэкенда можно посмотреть файл backend/pom.xml, для фронта — frontend/package.json. Отфильтроваф по dependenies.

3) Конфигурация (Config)
Храним переменные для подключения к различным внешним сервисам в конфигурационных файлах, которые сохраняются в используемом нами окружении, а не в коде. Наши внешние подключения должны быть определены в переменных, как и другие вещи, которые можно параметризовать в приложении. Они не должны быть «захардкожены», их стоит передавать во внешних конфигах приложения. Сейчас мы отлично используем для этого переменные из environment в связке с systemd.

Ответ: Считаю, что данный пункт подходит. Все "секретные" данные хранятся в переменных Gitlab.

4) Сторонние службы (Backing services)
Сторонние службы — это любые сервисы, которые использует приложение. Например, база данных, Message Queue или REST API.
Любые изменения в сторонних службах должны происходить без изменения кода приложения. Например, если postgreDB на проде испытывает проблемы с производительностью, мы можем перенаправить запросы от приложения на другой хост с postgres, не пересобирая приложение. То есть адреса сторонних служб не должны быть «захардкожены», их стоит передавать во внешних конфигах приложения.

Ответ: Считаю, что этот пункт на данном этапе не подходит. Так как пока сторонние службы для приложения не используются.

5) Сборка, релиз, выполнение (Build, release, run)
Стоит строго разделять 3 стадии превращения кода в запущенное приложение:
сборка — создание исполняемого артефакта. На этом этапе притягиваются зависимости, код компилируется в бинарные файлы
релиз — соединение исполняемого артефакта с конфигурацией под среду, на которой он будет запущен
выполнение (runtime) — запуск и исполнение приложения на целевой среде
Любое изменение в коде должно пройти через все три стадии. Полученные релизы сохраняют с уникальным названием, содержащим время сборки или номер коммита с изменением. Это позволяет легко откатиться в случае проблем — просто запустить предыдущий релиз.

Ответ: Считаю, что данный пункт подходит. Так как наше приложение проходит все 3 стадии - build (and test), release, deploy.

6) Процессы (Processes)
Приложения для развёртывания в облаке не должны хранить внутри себя файлы с состоянием — для этого подключаются внешние источники хранения: s3, базы данных и т.д. Да, кэш приложения всё ещё предполагается для использования на конкретной транзакции, но в целом из-за того, что приложение может быть в любой момент перезапущено из-за масштабирования, обновления или ошибки, всё необходимое для сохранения должно быть сохранено вне приложения.

Ответ: Не уверен по данному пункту. Думаю, что подходит, так как артефакты хранятся в Nexus.

7) Привязка портов (Port binding)
Предполагается, что каждое приложение будет иметь собственный порт для работы с ним, быть самодостаточным, а не запускаться внутри контейнера веб-приложения. Сейчас написаны специальные фреймворки, которые умеют так работать «из коробки»: Flask для Python или Spring Boot для Java.

Ответ: Считаю, что данный пункт подходит. backend использует Spring Boot для Java, frontend пробрасываем на 80 порт.

8) Параллелизм (Concurrency)
Написанное приложение должно иметь возможность масштабироваться, не ограничиваясь только вертикальным масштабированием, когда мы выдаем виртуальной машине больше ресурсов, но и иметь возможность расширяться между несколькими виртуальными машинами.

Ответ: Считаю, что этот пункт на данном этапе не подходит. Так как у меня одна ВМ, на которой запускается одно приложение.
*другие технологии пока не рассматривались в программе обучения, поэтому отвечаю по текущему состоянию.

9) Утилизируемость
Стремимся уменьшить время старта приложения и его работу, так как мы не храним состояние, то будет лучше если наша программа как можно меньше по времени хранит состояние в кэше. Остановка приложения не должна зависать, вызывать проблемы. Приложение корректно завершается по сигналу SIGTERM.

Ответ: Не уверен по данному пункту. Но думаю, что пункт подходит. Так старт/остановка приложения проходит без проблем, без какого0либо отрицательного влияния на систему.

10) Паритет разработки/работы приложения
Стремимся уменьшить различия между тестовыми и продуктивными средами.
Уменьшаем время сборки и деплоя. Свежий код может быть задеплоен на прод через несколько часов, а то и минут после написания, если все тесты прошли успешно.
Разработчики имеют доступ к продуктивному окружению, могут видеть на нём результаты своей работы.
Стремимся держать продуктивные и тестовые стенды в одинаковом состоянии. Одинаковые инструменты, одинаковые версии пакетов.

Ответ: Не уверен в данном пункте. Но если считать ветку main продуктивной средой, а другие ветки - тестовой, то данный пункт подходит.
dev/prod modes пока не рассматривали.

11) Журналирование (Logs)
Если обычно мы работаем с приложением, которое обучено писать логи в конкретный файл, умеет настраивать уровень логирования, заниматься их ротацией и т.д, то в приложениях для работы в облаках мы выводим логи в консоль в классический stdout, а управлением логами, их хранением, занимается внешний сервис. Частенько эти логи перенаправляются в централизованное хранилище и там индексируются, для удобства работы с ними.

Ответ: Считаю, что этот пункт на данном этапе не подходит. Так как у нас еще не настроено корректное логирование всего приложение, централизованных хранилищ логов также нет.

12) Задачи администрирования (Admin processes)
В жизни периодически возникают ситуации, когда для дополнительных задач нам необходимо выполнить скрипты, которые должны создать новых пользователей в базе, очистить очередь, подключиться дебагом к выполняемым процессам или исправить другую конкретную проблему. Для этого у нас должна быть возможность подключиться к работающему приложению и запустить лежащие рядом с основным кодом специальные служебные скрипты. Чтобы такие скрипты без проблем отрабатывали на нашем окружении, необходимо дать им возможность использовать основные переменные приложения.

Ответ: Считаю, что этот пункт частично подходит. Так как на стадии деплоя мы используем рядом лежащий скрипт для задач деплоя.

